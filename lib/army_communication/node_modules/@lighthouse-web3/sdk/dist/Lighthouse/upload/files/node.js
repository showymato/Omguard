"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.walk = void 0;
const basePathConvert_1 = __importDefault(require("../../utils/basePathConvert"));
const lighthouse_config_1 = require("../../../lighthouse.config");
const util_1 = require("../../utils/util");
async function walk(dir) {
    const { readdir, stat } = eval(`require`)('fs-extra');
    let results = [];
    const files = await readdir(dir);
    for (const file of files) {
        const filePath = `${dir}/${file}`;
        const _stat = await stat(filePath);
        if (_stat.isDirectory()) {
            results = results.concat(await walk(filePath));
        }
        else {
            results.push(filePath);
        }
    }
    return results;
}
exports.walk = walk;
exports.default = async (sourcePath, apiKey, dealParameters) => {
    const { createReadStream, lstatSync } = eval(`require`)('fs-extra');
    const path = eval(`require`)('path');
    const token = 'Bearer ' + apiKey;
    const stats = lstatSync(sourcePath);
    try {
        const endpoint = lighthouse_config_1.lighthouseConfig.lighthouseNode +
            `/api/v0/add?wrap-with-directory=false`;
        if (stats.isFile()) {
            const data = new FormData();
            const stream = createReadStream(sourcePath);
            const buffers = [];
            for await (const chunk of stream) {
                buffers.push(chunk);
            }
            const blob = new Blob(buffers);
            data.append('file', blob, path.basename(sourcePath));
            const response = await (0, util_1.fetchWithTimeout)(endpoint, {
                method: 'POST',
                body: data,
                timeout: 7200000,
                headers: {
                    Authorization: token,
                    'X-Deal-Parameter': dealParameters
                        ? JSON.stringify(dealParameters)
                        : 'null',
                },
            });
            if (!response.ok) {
                throw new Error(`Request failed with status code ${response.status}`);
            }
            let responseData = (await response.text());
            responseData = JSON.parse(responseData);
            return { data: responseData };
        }
        else {
            const files = await walk(sourcePath);
            const data = new FormData();
            for (const file of files) {
                const stream = createReadStream(file);
                const buffers = [];
                for await (const chunk of stream) {
                    buffers.push(chunk);
                }
                const blob = new Blob(buffers);
                data.append('file', blob, (0, basePathConvert_1.default)(sourcePath, file));
            }
            const response = await (0, util_1.fetchWithTimeout)(endpoint, {
                method: 'POST',
                body: data,
                timeout: 7200000,
                headers: {
                    Authorization: token,
                    'X-Deal-Parameter': dealParameters
                        ? JSON.stringify(dealParameters)
                        : 'null',
                },
            });
            if (!response.ok) {
                throw new Error(`Request failed with status code ${response.status}`);
            }
            let responseData = (await response.text());
            responseData = JSON.parse(responseData);
            return { data: responseData };
        }
    }
    catch (error) {
        throw new Error(error.message);
    }
};
